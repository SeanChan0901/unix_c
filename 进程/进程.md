# 进程的基本知识（启用root）

## 进程标识符pid
   - 类型 ```pid_t``` （有符号16位整形）
   - 命令 ```ps``` 打印当前进程的情况 ```axm```, ```axf```, ```ax -L``` 还有很多。
   - 进程标识是顺次向下使用。即使有释放的也不会往回找。
   - ```getpid()``` ```getppid()```

## 进程的产生 ```fork()```
   - ```fork()``` 创建一个新进程（复制父进程：**duplicating**，一摸一样，连执行到的位置都一样）
   - fork之后父子进程的区别:fork的返回值不一样，父子进程的```pid``` ```ppid``` 是不一样的。未决信号和文件锁不继承，资源利用量归零。
   - init进程：1号进程。是所有进程的祖先进程。
   - 永远不要猜测父子进程之间谁先调度，因为这个是由调度器的调度策略来决定的 。
   - ***在```fork```之前一定要加入```flush```刷新缓冲区里面的所有内容***！！！！
   - ```./ | wc -l``` 命令可以用于计算行数
   - ```time ./ ``` 可以用来计算运行时间
   - 重定向命令 ```./<...>  > /tmp/out```
   - 可以重定向到一个空设备```> /dev/null```
   - ```kill```命令是用于杀死进程。
   - zombie(僵尸进程)：应该是一瞬即逝去的，你过几秒去看可能又换了一批僵尸进程，僵尸进程存在的原因有两个，要么操作系统比较忙，要么父进程比较忙，没来得及收尸。需要过一段时间批量来收尸。zombie大量存在其实占不了多少内存，不会争抢很多资源。但是占据的比较重要的资源为：**pid**。
   - 子进程结束一定要记得 ```exit```
   - 孤儿进程会被init接管，结束之后init会帮他们收尸。
   - fork现在加入了***写时拷贝技术***。如果父子进程都是只读，就不会复制（资源）。如果有一个人企图通过某一个指针去写，就会memery copyy一份，在copy的内容去改，谁改谁复制。

## 进程的消亡以及释放资源
   - ```wait()``` ：用宏传参判断进程是什么状态的退出 ```man 2 wait```(死等，等它终止或者被信号打断，等他状态发生变化，是阻塞的)
   - ```waitpid()```：不用死等，可以传参灵活调整，是非阻塞的。pid的值有很多种可能。pid=0的话就收同组的自己的子进程。pid=-1收任意一个子进程。
   - ```waitid()```
   - ```wait3()``` :FREEBSD的方言
   - ```wait4()``` :FREEBSD的方言

## 进程的分配方法
   - 分块
   - 交叉分配
   - 池（能者多劳）

## exec函数族：用新的进程image替换原有的image(你还是你，但是你已经不是你了，pid是不会变的)
   - 如果有返回就证明出错了。
   - 一定要注意```fflush```的使用，在使用之前刷新所有的流。
   - ```execl()```（定参）
   - ```execlp()```（定参）
   - ```execle()```（定参）
   - ```execv()```（变参）
   - ```execvp()```（变参）
   - 注意灵活利用 **envrion

## 用户权限及组权限
   - ```password``` 的权限是怎么来的。
   - u+s权限:只要一个可执行文件有u+s权限那么在任何用户运行它的时候就会以user的身份来运行。（root的权限打散，下放）
   - g+s权限:只要一个可执行文件有u+s权限那么在任何用户运行它的时候就会以同组的身份来运行。（root权限打散，下放）
   - 权限有实际上不是一份的，而是三份，分别是 ```real``` ```effective``` ```save```，其中鉴定权限看的是```effective```权限。
   - 当前```shell```的身份来源于：
   - ```getuid()``` ```geteuid()``` （saveid有的环境有，有的环境没有）
   - ```getgid()``` ```getegid()``` 
   - ```setgid()``` ```setuid()```
   - ```setegid()``` ```seteuid()```
   - ```setregid()``` ```setreuid()``` ：交换eid和rid，参数要看man手册
   - 两个命令 ```chmod``` ```chown``` 改变权限和改变所有者。

## 观摩课：解释器文件
   - 解释器文件说白了就是脚本文件（.sh .py之类的，其实叫什么都没关系）
   - 开头以这个开头 ```#!/bin/bash``` （bash下运行后面的命令）
   - ```#!/bin/cat``` 这样都可以装载成功，会在原来的shell下把cat当作命解析本文件内容。P58详解。
   - 一条命令的失败不会影响其他命令的执行。
   - 看到了脚本文件的标记 #! 就会把指定的解释器装载进来，然后用这个解释器来解析**全部**内容（包括第一行）。```#``` 其实是注释的意思，所以解析器不会解析它。

## system() 看linux的man手册
   - 通过调用sh来执行可执行二进制文件的。
   - 可以理解为 ```f&e&w```的封装。

## 进程会计
   - ```acct()``` 方言

## 进程时间
   - ```times()``` time命令就是用它来封装的。

## 守护进程
   - 比如：系统级的模块（开机之后一直在跑） 
   - 守护进程一般脱离控制终端（防止终端干扰）
   - 守护进程一般是个会话的leader，一个group的leader
   - 进程组分为前台进程组和后台进程组，前台进程组最多只有以恶搞（可以没有），后台进程组可以有多个，前台进程组可以进行输入输出，而后台不可以，如果我们要后台进程接收一个输入那么就会杀掉原有的后台进程。
   - 会话（session）：一次成功的shell登陆可以模拟成一次会话。标识:sid。```setsid()``` 只能子进程调用，不能父进程调用（只能不是group leader的进程调用）。创建新会话，创建新的组，并成为leader,**并且脱离控制终端(tty)**。符合守护进程的特点。
   - 守护进程不需要收尸，运行起来之后可以让父进程结束。
   - 守护进程的特点：**ppid=1（init）,pid=pgid=sid（sess leader & group & leader）,tty=?（脱离控制终端）**
   - ```getpgrp()```
   - ```setpgid()```
   - ```setogid()```
   - 终端（terminal）：
   - 单实例守护进程：锁文件 /var/run/name.pid （不能给它跑好多次）
   - 启动脚本文件：/etc/rc*... （开机启动）

## 系统日志
   - 每一个应用程序都应该写系统日志，但是又不能人人都能写（防止篡改）
   - 路径 ```cd /var/log/```
   - rsyslogd服务:负责收集内容，统一写。（root权限分离）
   - ```openlog()``` 关联日志文件
   - ```syslog()``` 提交日志  注意不要写\n，格式是由syslog来定的，写/n会被提交到系统日志里面去。
   - ```closelog()``` 关闭关联
   - 配置文件规定了哪个级别以上的才可以写系统日志文件

