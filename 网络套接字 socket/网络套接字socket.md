# 网络套接字socket

## 讨论：跨主机传输需要注意的问题
1. 字节序问题：
   - 大端存储：低地址处放高字节
   - 小端存储：低地址处放低字节
无论是大端存储还是小端存储都是低地址处先出去。
   - 主机字节序：host
   - 网络字节序：network
   - _ to _ _: 如：```htons``` ```htonl``` 后面的s和l待别short和long，两位和四位。htons表示主机到网络。```ntohs``` ```ntohl```
2. 对齐：我们的编译器为了加速编译一般都会对结构体类型的数据做对齐操作。如果是要进行网络
   传输要告诉编译器不要对齐。
   ```cpp
    struct data{
      int i;
      float j;
      char ch;
    }
   ```
   上述结构体一般占据9个字节，但是编译器进行对齐知乎（假设进行4字节对齐，那么就占用12个字节）可以理解为一个公式：如果一个起始地址号能整除我的成员的sizeof的话就放在这。
  
   如图：

3. 类型长度
   - int：在标准C中没有对int类型的数据做大小的明确规定。只是做了一个范围规定（char < int <= float < double），具体还是看机器。 
   - char:标准c对于char的有无符号是为定义行为。
   - 解决：int32_t uint32_t int64_t int8_t uint8_t。长度类型。


4. socket是什么：可以理解为一个中间才层，把下面的协议族与上面的实现联系起来的一个中间层就叫socket。```socket()```
   - 协议：自己man看一下，值得注意的是AF_PACKET：底层协议，作用于网卡，很多的抓包器和嗅探器都是依靠它，还有ipv4 和ipv6也很重要。
  
   - 传输形式：
   报式套传输：（无连接，不可靠，有最大长度）要求数据的分组以及数据的完整性，以一个数据包的形式进行发送，每一个结构体之间都有一个比较清晰的边界。

   流式套传输：有序的，可靠的，双工的，基于连接的流式的字节传输。有序可靠指的不是不丢包，丢包是一定的，有序可靠指的是只要接收方一接收到，能保证是有序的正确的。以字节流传输，没有规定的形式，比如我一次发了100个字节，接收方可以选择一次性接收50个接收两次，也可以一次性接收20个接收5次。没有清晰的边界。

   - 有序分组传输：结合了以上的特点（优点）
   - socket的第三个参数，选协议的时候可以填0，代表用协议族里面默认支持对应传输形式的的协议。

## 报式套接字：可以多点通讯
   ```cpp
   socket();
   bind();
   sento(); // rcvform
   inet_pton();
   inet_ntop();
   setsockopt();
   getsockopt();
   close();
   ```

   - 主动段：1）取得socket 2）给socket取得地址（可省略） 3）发/收消息 4）关闭socket
   - 被动端（先运行）：1）取得socket 2）给socket取得地址 3）收/发消息 4）关闭socket

   发包的一方可以省略绑定地址的操作，系统会自动分配一个空闲的地址给你，而被动端不行，一定要分配地址，不然主动段不知道你在哪，发不了包。

   - blind的参数中的 第二个参数struct sockattr其实是不确定的，是根据协议族变化的。

   - ip地址的点分式和大整数之间的转换：```inet_pton()```（专门转换ipv4和ipv6的地址）
   - ip地址是会不断变化的，如果不希望重复修改程序那么可以用:"0.0.0.0",意思就是在绑定地址这个阶段你的ip地址是多少那么这四个零就转换成多少。
   - ```inet_ntop()``` 点分式转大整数
   - 用命令 ```netstat -anu``` 查看报式套接字的网络状态
   - 多点通讯（只有报式套接字可以做到）：广播（全网广播，子网广播），多播/组播。组播比较好用比较灵活（个人认为）
   - 广播是默认禁止发送的，需要更改某个属性才可以发送。可以查看相关协议族的 socket option属性。
   - ```ifconfig```命令可以设置一些参数 ```ip ro sh``` ```ip ro```之类的命令可以查看网卡和路由信息。 
   - 广播会受到防火墙的影响。另外广播在man手册上写了如果打开之后会怎么样，并没有说关闭的时候会怎么样，所以接到也是可能的接不到也是可能的，是为定义行为。
   - 多播: ```if_nametoindex()``` 查看网络索引号,224.0.0.1表示一个组，所有支持多播的节点都存在这个组中并且无法离开。如果往这个地址发消息等于广播。

UDP传输分析：
   - TTL（time to live）指的是可以跳转的路由的总个数，在linux环境下一般会定义成64，在windows环境下一般会定义成128。这个数值是可以更改的。但是一般情况下是完全足够的了。
   - 丢报：是由于**阻塞**造成的。路由的等待队列会有一些丢包的算法实现，当我的包的容量到达一定的数量的时候就选择随机丢包，或者不再接收之类的。（断点续传协议）
   - 一般的网络服务不会进行硬性的数据校验，而会交给用户去做（如果看不到的话就刷新）
   - 流控：不能用开环的流控，要用闭环的流控：停等式流控（确保对方收到ACK）。
   - 其实使用停等式流控并不会降低丢包率，反而会提高丢包率，因为ACK也有丢的可能，停等式流控相当于牺牲了丢包率换来确保用户收到。
   - ftp状态机加入ACK功能。
   - RTT可以跟上一次返回时间做一个平均值来求。
   - 比较耗时，大段时间都消耗在等待上。

## 流式套接字：点对点，不需要反复确认身份。
TCP传输协议分析
   - 不断发包知道我收到第一个ACK为止，以后没收到一个ACK就发一个包等一个ACK。
   - 滑动式窗口：接一个ACK发两个包接一个ACK发两个包，想到与抢占沿途的路由器的资源（占他的小溪队列）。
   - 问题：这么多的包有可能是从不同的路径传输的，很难确定自己收到的是第几个包（先后到达顺序不能确定）
   - 三次握手：（本来是四次数据报的传输，结果有两个合并在一起了，所以三次握手）于是引入了流式套接字，安全稳定的点对点的数据传输。
   - 完成了第一二次握手的状态叫做半连接状态。在S端会有半连接池，在完成了两次握手的节点都把他们放入半连接池里面。当次三次握手的时候，在半连接池来找，如果存在的话就说明我们之前我们已经建立了前两次握手，第三次握手结束后进行正常的数据传输。
   - 攻击方式：半连接洪水，没有办法从根本上防范，攻击目的占满半连接池，就是不进行第三次握手。解决方法：我直接放弃半连接池，不用了。我用对端IP+对端端口+我端IP+我端端口+我俩都用的PROTOl，用上述的值和杂质sult进行哈希，得到的内容叫做cookie。在第二次握手的时候把cookie也送过去，当第三次握手的时候，你肯定带着cookie来，用这个公式再算一遍，发现cookie相同就握手成功。sult由内核产生，一秒钟变一次。会拿本一秒钟的sult算，如果相等，那么拿上一秒的sult算，如果还不想等，那么证明你的cookie过期了。在网络传输的过程中，2秒钟已经很长很长很长了。
   - 四次挥手：断开连接。

步骤：
   - C（主动端）
   1. 获取SOCKET
   2. 给SOCKET取得地址（可省略）
   3. 发送连接
   4. 收发消息
   5. 关闭


   - S端
   1. 获取SOCKET
   2. 给SOCKET取得地址
   3. 将socket置为监听模式
   4. 接受连接
   5. 收发消息
   6. 关闭

 - 机器默认安装了一个客户端，用```nc```命令可以查看。```nc ip port```这样的形式可以请求某一个ip地址的某个端口号。也可以用tellnet命令。
 - TIME_WAIT:一定要关闭端口（进程的正常结束，即close(sd)）,不然ctrl+c端口会进入TIME_WAIT状态。可以用```setsockopt()```的SO_REUSEADDR，使得还未释放的情况下可以绑定端口。

 - 纯文本的通信都是但字节的，所以不存在字节序问题。也就不需要对齐了。
 - 主机序列？？？网络序？？？
 - accept()函数天生支持互斥。
 - URL映射： 
   URL|FS
   :-:|:-:
   /|/var/www
   /cgi-bin|/var/www/cgi-bin

## 初始化级别
级别：默认值 配置文件 环境变量 命令行参数