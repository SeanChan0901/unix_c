# 网络套接字socket

- 讨论：跨主机传输需要注意的问题
1. 字节序问题：
   - 大端存储：低地址处放高字节
   - 小端存储：低地址处放低字节
无论是大端存储还是小端存储都是低地址处先出去。
   - 主机字节序：host
   - 网络字节序：network
   - _ to _ _: 如：```htons``` ```htonl``` 后面的s和l待别short和long，两位和四位。htons表示主机到网络。```ntohs``` ```ntohl```
2. 对齐：我们的编译器为了加速编译一般都会对结构体类型的数据做对齐操作。如果是要进行网络
   传输要告诉编译器不要对齐。
   ```cpp
    struct data{
      int i;
      float j;
      char ch;
    }
   ```
   上述结构体一般占据9个字节，但是编译器进行对齐知乎（假设进行4字节对齐，那么就占用12个字节）可以理解为一个公式：如果一个起始地址号能整除我的成员的sizeof的话就放在这。
  
   如图：

3. 类型长度
   - int：在标准C中没有对int类型的数据做大小的明确规定。只是做了一个范围规定（char < int <= float < double），具体还是看机器。 
   - char:标准c对于char的有无符号是为定义行为。
   - 解决：int32_t uint32_t int64_t int8_t uint8_t。长度类型。


4. socket是什么：可以理解为一个中间才层，把下面的协议族与上面的实现联系起来的一个中间层就叫socket。```socket()```
   - 协议：自己man看一下，值得注意的是AF_PACKET：底层协议，作用于网卡，很多的抓包器和嗅探器都是依靠它，还有ipv4 和ipv6也很重要。
  
   - 传输形式：
   报式套传输：（无连接，不可靠，有最大长度）要求数据的分组以及数据的完整性，以一个数据包的形式进行发送，每一个结构体之间都有一个比较清晰的边界。

   流式套传输：有序的，可靠的，双工的，基于连接的流式的字节传输。有序可靠指的不是不丢包，丢包是一定的，有序可靠指的是只要接收方一接收到，能保证是有序的正确的。以字节流传输，没有规定的形式，比如我一次发了100个字节，接收方可以选择一次性接收50个接收两次，也可以一次性接收20个接收5次。没有清晰的边界。

   - 有序分组传输：结合了以上的特点（优点）
   - socket的第三个参数，选协议的时候可以填0，代表用协议族里面默认支持对应传输形式的的协议。

报式套接字：
   - 主动段：1）取得socket 2）给socket取得地址（可省略） 3）发/收消息 4）关闭socket
   - 被动端（先运行）：1）取得socket 2）给socket取得地址 3）收/发消息 4）关闭socket

   发包的一方可以省略绑定地址的操作，系统会自动分配一个空闲的地址给你，而被动端不行，一定要分配地址，不然主动段不知道你在哪，发不了包。

   - blind的参数中的 第二个参数struct sockattr其实是不确定的，是根据协议族变化的。

   - ip地址的点分式和大整数之间的转换：```inet_pton()```（专门转换ipv4和ipv6的地址）
   - ip地址是会不断变化的，如果不希望重复修改程序那么可以用:"0.0.0.0",意思就是在绑定地址这个阶段你的ip地址是多少那么这四个零就转换成多少。
   - ```inet_ntop()``` 点分式转大整数
   - 用命令 ```netstat -anu``` 查看报式套接字的网络状态
流式套接字：点对点，不需要反复确认身份。
## 

