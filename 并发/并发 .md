# 并发

- 同步：所有分支都在你的控制中（所有要进行的操作在你的预料之中）
- 异步：这个事件什么时候发生，你并不知道，这个异步事件的到来会引发什么你并不知道。
  
- 异步事件的处理：查询法，通知法
    1. 查询法：盲目的定期查询（拿筛子定期去筛）。
    2. 通知法：浮标钓鱼，有鱼上钩浮标会通知我。

发生的频率比较稀疏，用通知法，如果比较频繁，用查询法。实际上并没有彻彻底底的通知法。

 ***注意：开发的时候千万不可混用线程和进程的并发！！***

## 信号
1. 信号的概念：
   - 信号是软件（层面的）中断
   - 信号的响应依赖于中断（有了中断，信号才能被响应）
   - ```kill -l``` 可以查看当前的信号。 
   - 信号分为标准信号和实时信号。(1-31是标准信号)
   - core文件是程序的某个现场，一般是出错现场。（一般我们使用的程序出错的时候，发送的错误报告就是core文件）
2. ```signal()```
   - ```void (*singal(int signalnmuber,void (*func)(int)))(int)``` 注意多写这个原型（防止名空间冲突），不要写man手册里面的那个，标准的头文件里面根本没有定义，所以用的时候要加上typedef，如果另外一个库里面也有这个东西那么就game over了（c没有名空间）。函数的含义：指定一个信号num,以及一个行为handler。这里**接收一个int表明可以多个信号公用一个信号处理函数。**
   - handler 可以是宏，也可以是一个函数的入口地址。
   - ```ctrl + c``` = SIGINT。```ctrl + \``` = SIGQUIT。
   - handler响应有两个条件，1）程序没结束 2）信号到来
   - 重要：***信号(handler)会打断阻塞的系统调用***
   - 信号处理函数要尽可能的小，小到一闪而过，尽量减少重入的可能性。
3. 信号的不可靠
   - 标准信号一定会丢失的，这不算是信号不可靠。
   - 信号不可靠指的是信号的**行为**不可靠，你没有人为去调用一个信号handler，而是当信号传来了，它自动发生的。那么当一个信号在处理的过程中又来了一个新的信号。由于执行现场是内核帮你布置的，这些信号的现场很有可能被布置在同一个位置，那么第二个信号来的时候很有可能把第一个信号的现场给冲掉。
4. 可重入函数
   - 为了解决信号的不可靠。
   - 第一次调用还没结束，就发生了第二次调用，并且不会产生错误。
   - **所有的系统调用都是可重入的。一部分标准库函数也是可重入的**，如：```memcpy()```（拷贝内存空间）,单也有部分标准库函数是不可重入的，如：```rand()```,对于这类函数，标准库又给出了一部分对应的可重入函数（可见man手册 这部分的函数的_r后缀的函数就是可重入的），不可重入的函数不可用于信号处理。
5. 信号的响应过程
   -  mask:信号屏蔽字，用来表示当前的信号的状态
   -  pending：用来记录收到哪些信号
   -  信号从收到到响应有一个不可避免的延迟。
   -  当一个进程被中断的时候，保存现场，压栈（扎入kernel态），然后，调度到你的时候，又从kernel态回到user态，还原现场。这个时候非常重要，要做一个表达式 mask&pending ，如果发现整个值等于0，那么就证明没有被中断。如果一个进程在运行的过程接收到一个信号 SIG_INT，那么就会反映到pending的一个位上，原本是0，那么就这个位会变成1。一切照常进行，正常中断，调度，当从k态回到u态的时候做 mask & pending 发现有中断。那么就执行对应的 handler。所以信号是有延迟的！！没有中断打断你，你就没办法看到信号：信号是依赖中断这个机制来响应的。
   -  那么信号响应的过程是怎么样的呢：如果收到了一个信号，把对应的位的mask 和 pending都置成0，然后换掉原来的返回地址addr,用handler的地址来替换，进入到handler中进行。响应完之后又回到内核，把刚刚更改的地址换回来。把mask对应位置成1。继续执行。（此时不知道对应的pending位是多少）
   -  如果接收了多个标准信号，是没有顺序的。先执行哪个后执行哪个并不知道。**标准信号的响应没有严格的顺序**
   -  **信号是从 k->u的路上响应的**
   -  思考：如何忽略掉一个信号的？```SIG_IGN```当作handler传入，把对应的mask位置成0，这个信号就会被忽略。你不能阻止信号的到来，但是可以决定是否对信号做出响应。
   -  **不能从信号处理函数中随意的往外跳(```setjmp``` 和 ```longjmp()```)。如果跳了的话，那么就错过了信号处理函数结束之后把mask由0设置为1的过程，那么就再也无法接收到这个信号了。**新的函数：```sigsetlmp()``` 和 ```siglongjmp()```
   -  思考：标准信号为什么要丢失？位图，来一万个1不还是1么，同一个**标准信号**是肯定会丢失的。
   ![信号响应过程图](信号的响应过程.jpg)
6. 信号相关的常用函数
   - ```kill()```：用于发信号。pid: >0 , =0(组内广播) , =-1(全局广播) , <-1(对应组广播)  
   - ```raise()```：相当于给当前进程发送一个signal
   - ```alarm()```：（时钟）定一个时延来发信号,没有办法实现多任务计时（多个alarm会出问题）（只有最后一个会生效）**注意**：只要是设置信号行为的操作一定要定义在```alarm()```之前。【例】：使用单一计时器来构造一组函数。 我实现任意数量的计时器。
   - ```pause()```：暂停，等待一个信号。考虑到移植性，尽量不要使用sleep因为有一些平台是用alarm + pause封装的sleep,会有问题的，alarm没法实现多个任务计时，如果用了sleep后又用一个alarm会出大问题。如果用循环来等待的话cpu的占用率会很高，因为在一直执行循环语句，pause可以用来作为等待，这个系统调用可以被信号打断
   - ```abort()```：人为的制造一个异常。
   - ```system()```：如果在有信号相关的进程中使用```system()```的话要block掉以一个信号ignore掉两个信号（具体看man手册）。实际上这个函数就是调用```/bin/sh```来完成你的命令。
   - ```sleep()```：缺点：有些平台的sleep是用alarm+pause封装的。所以说用一个以上的alarm是会出问题的。所以说尽量少用sleep。可以用```nanosleep()```和```usleep()```和```select()```来替换它，
   - 漏桶：无论来海量数据都不紧不慢的读，如果没有数据了，那就闲着。
   - 令牌桶：积攒权限，一次使用。使用万积攒的权限之后就恢复正常。
7. 信号集 ```man sigemptyset```自行查看
   - 信号集类型：```sigset_t```
   - ```sigemptyset()```
   - ```sigfillset()```
   - ```sigaddset()```
   - ```sigdelset()```
   - ```sigismemberset()```
8. 信号屏蔽字/和信号判定集的处理
   - ```sigprocmask()```:给了我们人为的方式来干扰信号。我们可以决定信号什么时候可以被响应。记住，怎么进来，怎么出去。
   - ```sigpending()```:以信号集的形式告诉你现在收到了哪些信号，在你取出来的时候就已经响应完了（信号）。好像并没有什么用的一个函数。
9.  扩展函数
   - ```sigsuspend()```：相当于屏蔽等待和结束屏蔽3个操作进行原子化操作。可以做一个信号驱动程序，完成```pause()```完成不了的操作。因为不能原子化，所以```pause()```完成不了**信号驱动程序**。
   - ```sigaction()```：signal函数有一个缺点，就是当信号处理函数处理多个信号的时候可能发生重入现象。(两参和三参的区别)。三参的最后一个参数void*是一个可还原的现场（见ugetcontext）（不要再用了）。
   - ```setitimer()``` ：用到时钟的时候，尽量使用这个而不是alarm。优点：误差不累积。
11. 实时信号（kill -l查看信号）
    - 实时信号要排队的。
    - 实时信号的响应是有一定顺序的。（标准信号的响应是未定义行为）
    - 同时收到标准信号和实时信号，先响应标准信号，后响应实时信号。
    - ```/usr/include/bits/signum.h```存放着所有信号。（mac上没有，用linux再去试一下suspend_rt)
    - **实时信号是不丢失的** 

12. 多进程并发是先有事实，再制定标准的。所以不太好用，比较难理解。而多线程并发是先制定标准再有事实的。所以比较好理解。

## 线程
一次成功的shell登陆其实就是一次会话，会话是用来承载进程组的，会话可以有一个或者多个进程组。每个进程组可以有一个或多个进程。一个进程当中可以有一个或多个线程。

线程说白了就是一个正在运行的函数。多个线程之间是兄弟关系，兄弟之间同时独立运行，不分主次。多线程之间内存共享，因为在同一块进程的地址空间内。

现在发布的库默认情况下都必须支持多线程，如果不支持的话必须在函数名内说明。

posix线程是一套标准，而不是实现。（只告诉你标识一定要用哪个标识，一定要完成什么功能，具体怎么实现看各自的系统）

1. 线程的概念:
   - 一次成功的shell登陆其实就是一次会话，会话是用来承载进程组的，会话可以有一个或者多个进程组。每个进程组可以有一个或多个进程。一个进程当中可以有一个或多个线程。

   - 线程说白了就是一个正在运行的函数。多个线程之间是兄弟关系，兄弟之间同时独立运行，不分主次。多线程之间内存共享，因为在同一块进程的地址空间内。

   - 现在发布的库默认情况下都必须支持多线程，如果不支持的话必须在函数名内说明。

   - posix线程是一套标准，而不是实现。（只告诉你标识一定要用哪个标识，一定要完成什么功能，具体怎么实现看各自的系统）
   - 线程标识：```pthread_t```（各家实现不一样，不能建党的）
   - ```ps axm``` 进程下面的横向就是线程记录（同时跑着多个函数）
   - ```ps ax -L``` 以linux的方式查看进程，你会发现其实linux系统下是以线程的方式来消耗进程号（pid）的，尽管它对外的线程标识是一个pid。进程就是一个容器，里面有多个线程。（小范围的混用线程和信号可以混用，其他不推荐）
   - 在线程中做到线程安全比信号那边做到进程安全条件要松散。
   - ```pthread_equal()```：用来比较两个线程号的id。
   - ```pthreda_self()``` 返回当前线程标识。
2. 线程的创建，线程的终止，线程的取消选项，线程栈清理
   - 线程的创建：```pthread_create()``` 失败的话直接返回errno，而不是设置errno。现在的errno被做成一个宏了（线程私有化的数据）
   - 线程的调度取决于调度器的策略。
   - 线程的终止有3种方式：1）从启动例程中返回，返回值就是线程的退出码 2）线程可以被同一进程中的其他线程取消 3）线程调用pthread_exit()函数。
   - ```pthread_join()```：线程收尸，相当于进程的```wait()```
   - 栈的清理：```pthread_cleanup_push()``` 和 ```pthread_cleanup_pop（）```。
   - 每一个```pthread_cleanup_push()``` 后面（不一定紧随其后）都要跟一个```pthread_cleanup_pop（）``` 不然编译的时候编译不过去。（{}）（实际上是宏你可以man一下看一下）
   - 线程的取消选项： 一个线程在执行的过程中一定会用到线程的取消，这个很常见。就比如多个线程一同查找一棵二叉树的一个节点，如果一个线程查找到了，那么其他线程就没有必要继续了。这时候就可以用到线程的取消。然后去收尸（一个线程在正常运行的时候是没有办法收尸的，这时候就要用到线程的取消）```pthread_cancel()```函数用于取消线程。
   - 取消有两种状态，一种是允许，一种是不允许。允许取消又分为异步cancel和推迟cancel（默认），cancel推迟到cancel点再响应。
   - cancel点：POSIX定义的cancel点，都是可能引发阻塞的系统调用。
   - ```pthread_setcancelstate()``` 设置是否允许取。```pthread_setcanceltype()``` 设置取消方式。```pthread_testcancel()```本函数什么都不做，本身就是一个cancel点（本身没有任何取消点的时候用这个函数可以人为设置一个取消点）。
   - 线程分离：```pthread_datch()``` 不关心他的生死存亡，不管他了，该生生该死死。跟我没有关系了。**已经detach的线程是不可以被join的**
   - 强制转换会导致丢失精度。
   - 一个三十二位的机器，不更改栈大小的情况下一般一个进程最多拥有300多个线程。
3. 线程间的竞争
4. 线程同步：
   - 互斥量（锁）：```pthread_mutex_init()```(静态初始化，动态初始化) ```pthread_mutex_lock()``` ```pthread_mutex_destory()``` ```pthread_mutex_trylock()``` ```pthread_mutex_unlock()```man手册一定要看。
   【面试题（其实是不态规范的不要去使用）】:四个线程分别往终端打印四个字符abcd，注意锁量是为定义行为，出错也对不出错也对。
   - 除了测试，不要使用sleep函数
   - ```sched_yield()``` 出让调度器给别的线程，不会造成线程状态的颠簸。如果用sleep的话线程的状态会在running和sleep状态反复横跳，而这个函数意思就是running状态只不过调度器给你了，你先被调度。
   - **一定要注意临界区里面的所有跳转，一定要小心小心再小心。如果是跳转到临界区，那么就可以直接跳转，否则一定要解锁再跳转**。
   - 动态模块的单次初始化函数 ```pthread_once()```
   - 条件变量：```pthread_cond_t``` ```pthread_cond_init()``` ``` pthread_cond_destroy()``` ```pthread_cond_broadcast()```(全部叫醒) ```pthread_cond_signal()```(唤醒任意一个等待，具体是哪个等待并不知道)  ```pthread_cond_unlock()```  ```pthread_cond_wait()``` ```pthread_cond_timewait()```
   - 信号量：（资源量化上限）
   - 读写锁：互斥量+信号量的结合（自己回去实现一下），读锁（可以加多个读锁，加了读锁不能加写锁），写锁（只能有一个写锁），小心写者饿死行为。方法：欺骗后来的读者。
5. 线程的属性，线程同步的属性： ```man pthread_create``` 中的第二个参数。
   - ```pthread_attr_init()``` 线程属性产生函数。
   - 资源上限不要太当真，要看系统具体的情况。
   - 线程代码段是公用的，栈是独立的。
   - 互斥量属性：互斥量也有属性。
6. 可重入
7. 线程与信号，线程与```fork()``` 
