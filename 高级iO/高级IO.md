# 高级IO

## 非阻塞IO  -- 阻塞IO
-  阻塞假错  ```ENTRE``` 慢设备会被信号打断。非阻塞假错```EAGIAIN``` 没成功就返回。并不代表程序有问题。
- 高级IO主要讲的非阻塞IO，
- **有限状态机（编译原理）**
1. 非阻塞IO：
   - 我们写的大多数函数都是阻塞的。
   - 中继模型：很多服务都是在这个中继模型拓展开来的。
   - 简单流程：自然流程是结构化的
   - 复杂流程：自然流程不是结构化的
2. IO多路转接：
   - 监视文件描述符的行为```select()```:古老，兼容性好，但本身接口有缺陷，以事件为单位组织文件描述符,可以完成一次安全可靠的睡眠。最大的文件描述符+1,返回感兴趣的文件描述符在集合里。缺点1：监视集合和结果集合存在一起，只要一出现事件集合就会被清空，重新设置很麻烦。缺点2: ntfs有溢出的可能性，因为我的fd个数是可以改的，一旦超过有符号整形int的最大值，那么就会溢出。缺点3:除了读写事件，其他全部当作异常，异常集合非常大。监视类型太少了。特点：可以用全默认来作为alarm的替代品。
   -  ```poll()```：以文件描述符为单位组织事件，也可以移植。timeout = 0 , -1 >0三种情况。成功的话返回一个整形，表示多少个事件发生了。
   -  ```epoll()```：提升poll的效率（linux的方言）移植性相对不太好。```epoll()```是使用了系统调用，把布置工作封装了一下，不让你直接操作这个数组。让kernel来帮你完成这个手动布置的工作。size只要给一个常规数值就可以。精华所在就是那个unio结构体，可以存储除了文件描述符以外的其他信息。
   -  布置监视现场，布置监视任务。
3. 其他读写函数
   - ```readv()``` ```writev()``` ```preadv()``` ```pwritev()``` 可以对多个buffer做读写操作。
   - ```readn()``` ```write()```其实就是读或者写坚持写完读完。
  
4. 存储映射IO
   - ```mmap()``` :能做到一个非常好的非常快的共享内存。返回值是void*是最好用的了，void *可以给任何指针，任何指针都可赋值给void *.
   - 可以完成父子进程间的通信。
   - ```munmap()```
5. 文件锁 : 下载的时候的空洞文件就是多线程并发，各自对自己的部分上锁。
   - ```fcntl()```
   - ````lockf()```：如果长度参数是0，那么就从当前位置到要多长锁多长。
   - ```flock()```
   - ```echo 1 > /tmp/out``` 写文件
   - 文件的意外解锁的现象。（多个文件描述符结构体指向同一个inode的时候）
  
## 