# 标准IO笔记

>input &output 是实现一切的基础

>在unix里面，一切皆文件

>stdio:FILE类型贯穿始终

## 打开关闭流函数 ```fopen()``` 和 ```fclose()```  
- ```FILE* fopen()``` 函数返回的空间地址是什么类型的空间地址？ 
  1. ~~栈~~：如果是存放在栈中，那么 ```fopen()``` 会有以下形式的代码
        ```c++
        FILE *fopen(){
            FILE temp;
            temp.etc = xxxx;
            // ··· ···
            return &temp;
        };
        ```
        由于 ```FILE``` 类型的结构体 ```temp``` 是局部变量，所以这样的返回是没有效的。

  2. ~~静态区~~ ：```static``` 变量存在于整个编译单元，有且仅有一个，所以如果是静态区的话代码如下：
        ```c++
        FILE *fopen(){
            static FILE temp;
            temp.etc = xxxx;
            // ··· ···
            return &temp;
        };
        ```
        这样的画，一个进程打开多个文件的画，上一个文件就会被覆盖，**这很显然是不可能的** 。

   1. 堆：
        ```c++
        FILE *fopen(){
            FILE *temp = malloc(sizeof(FILE));
            temp.etc = xxxx;
            // ··· ···
            return temp;
        };
        ```
        由于每一个 ```fopen()``` 都与一个 ```fclose()``` 对称，故是在堆上创建的。一申请，一释放。

- **有宏名用宏名，别用宏值** 。
- 谁打开谁关闭，谁申请谁释放。
- 是资源就有上限（保险起见自己写代码的时候也写一个上限）。
- 当不改变环境的情况下，一个进程打开，默认打开三个流 ```stream```
- - ```stdin``` 边准输入流
- - ```stdout``` 标准输出流
- - ```stderr``` 标准报错流
  
  所以一个进程最多打开 $1021+3=1024$ 个文件

- 用 ```ulimit -a``` 可以查看所有限制，可以自己 **更改** 某些限制。

- 一个新建文件权限默认值为 $0666 &  ~umask$ 
  
        8进制代码 | 权限表示 | 权限
        :-: | :-: | :-:
        0 | ---- | 没有权限
        4 | -r-- | 只读
        5 (4+1） | -r-x | 只读+换行
        6 (4+2) | -rw- |  读写
        7 (4+2+1) | -rwx | 读写+换行

        --------------------------------
        常用linux文件权限
        --------------------------------

        权限名 | 权限表示 
        :-: | :-:
        444 | r--r--r--
        600 | rw-------
        644 | rw-r--r--
        666 | rw-rw-rw-
        700 | rwx------
        744 | rwxr--r--
        755 | rwxr-xr-x
        777 | rwxrwxrwx
        
        其中，1～3位表示文件所有者权限，4～6位表示同组用户的去啊线，7～9位表示其他用户的权限。

## 字符输入输出函数 ```fgetc()``` ```fputc()``` ```fgets()``` ```fputs()``` ```fwrit()``` ```fread()```
- 一个函数可以定义为 **函数** ,也可以定义为 **宏**(依赖内联函数，也就是define一个带参的宏)
  - 函数占用调用时间，不占用编译时间。（稳定安全，建议使用函数）
  - 宏占用编译时间，不占用调用时间。
  内核链表为了节约运行时间，把所有函数都定义成宏 

- ```fgetc()``` 返回的是一个整形，如果返回结果是 $EOF$ 那么代表获取失败（值为-1），注意不要用 ```char``` 来接受不了字符串，因为ISO C对有符号的字符串是没有定义的，所以会丢失一部分返回值。
  
- 不要使用 ```gets()``` ,因为他是不检查缓冲区溢出的缓冲区溢出的（不知道buffer多大）（防止溢出），```gets()``` 函数只接受一个 $char$ 类型的指针，但这个指针只是指向一个地址，并没有说明这个字符串的长度是多少（要去多少个字符）。所以不应该使用。应该转而使用 ```fgets()``` 这个函数，（指定了字符串长度）。

- 如果 ```fgets()``` 在读取任何字符之前读到一个 ```"\n"``` ，那么返回 $NULL$ ，buffer的内容保持不变，如果是遇到一个 $error$ 那么，buffer的内容是 undetermined 无法预测的。
  
- ```fgets()``` 函数正常结束有两种情况，
  1. 遇到一个 "\n"
  2. 读到 $SIZE-1$ 个字符的时候
   
- 注意任意一个字符串都以 $"/0"$ 结束，所以长度为 $size$ 的字符串里面只有 $size-1$ 个字符和一个$"/0"$。
- 一个例子，字符串 $abcd$ 用 ```fgets(ch,SIZE,fp)``` 来读要读几次？

   答：两次，第一次读 $abcd$$"/0"$ , 第二次读 $"/n"$。

- ```fread()``` 是返回 ```**成功**``` 读到对象的个数。读取方式是按照整个对象来读，注意，如果文件中出现一点错误（哪怕是一个字节的小错误），都会导致整个读取出错。而且，如果数据量最后不够被读取一个对象（比如数据量只有5个字节，但是一个对象占10个字节，那么用```fread()``` 函数是返回0,具体读到多少个字节是无法得知的），你是无法直到你读到的文件到底具体是有多少个字节的，所以建议还是按照一个字节一个字节来读。 
  

## ```printf()```
- ```printf()``` 将待输出内容按照一定的格式输出到标准输出流 ```stdout```。
- ```fprintf()``` 可以将带输出内容按照一定的格式输出到指定的 **流** 中去如 ```stderr```    ```stdout``` 等，也可输处到指定的文件中去（输出重定向）。 
- 标准输出流如 ```stderr``` ```stdout``` 指向标准输出设备，如：显示器。标准输入流 ```stdin``` 指向标准输入设备，如：键盘。
- 所有带 ```size``` 的函数都存在一个问题，因为不知道源文件的大小具体是多少字节（不知道该怎么读），又或者我需要的长度```size``` 没有办法满足。
- 如果没有特殊要求，一定要在 ```printf()``` 中加上\n， 输入输出缓冲区一定会在一行满了之后或者遇到 "\n" 才会刷新缓冲区。

## ```scanf()```
- 慎重使用 ```%s```。因为你要读取东西的时候，是不知道源文件具体有多长，也看不到目标位置到底有多大。这种字符串数组容易溢出。


## 文件位置指针：```fseek()```,```ftell()```,```rewind()```
- 如果是 ```long``` 型的数最好传参的时候把它常量化写成 ```0L``` 这样的形式。
- ```rewind()``` 意思就是 ```(void) fseek(fp,0L,SEEK_SET)``` 。回到开始位置。
- ASCII 码为0的字符：空字符(不是"\0")。
- ```fseek()``` 可以用于处理空洞文件。（迅雷下载，点一下下载文件会在目录位置出现一个不可读的文件，这个文件一般不是一点点涨上去的，而是一开始就这么大的 ***空洞文件***，把这个文件切成片，用多线程或者多进程进行每一小块的下载（用多线程的会比较多）。就好比，他在下载之前，如果空间不足就会提醒你空间不足，而不会在下载的过程中突然告诉你空间不足。
- 由于 ```ftell()``` 返回的是无符号的long（文件位置只有正的没有负的），这样一来就少了一半，假设long是32位的，那么可以表示 $-2^{31}$ 到 $2^{31}$ 大小的文件（大概就是-2G到+2G），但是被截断了，只能表示 $0～2G$ 的文件位置，可是 ```fseek()``` 所接受的参数```int offset```是可以有正有负的（往前往后的偏移量），假如一个文件 $2G$ ，放到 ```fseek()``` 中可以表示上下 $2G$ 合共 $4G$的大小。
- 而且现在的文件大小，超过 $2G$ 是非常轻松的事情，所以用的时候要慎重！！！
- ```fseeko()``` 和 ```ftello()``` 定义了一个 ```off_t``` 可以表示更大的数，用以决绝问题。但是他们不遵循ISO C所以移植性较差（注意看man手册，off_t在不同的architecture下为32位或者64位，但是不确定一定是32位置还是64位置，要使其为64，要定义一个宏）
  

## 刷新流 ```fflush()```
- 如果传递的参数为 ```NULL``` 则刷新 **所有** 打开的 **输出流**。
  
## 缓冲区
- 缓冲区的作用：大多数情况下是好事，合并系统调用
  1. 行缓冲：换行的时候刷新，满了的时候刷新，强制刷新（比如标准输出就是行缓冲模式，因为是终端设备）
  2. 全缓冲：满了的时候刷新，强制刷新（默认，只要不是终端设备，大多都是全缓冲）
  3. 无缓冲：如stderr（需要立即输出的内容，比如报错，需要立即输出）

## 获取流一行的函数 ： ```getline()```
- 写程序特别介意写出一些我不能管控的分支，所以一定要注意好范围（取反），就好比一个函数返回值为 $>=0$ 时候成功，$==-1$ 时候失败，那么最好写成 ```if(x<0) 失败```，如果写 ```f(x==-1) 失败``` 的话，那么，如果出现了-2,-3这些情况该怎么办呢？？？
- 动态分配内存，使可以取到一整行。

## 临时文件：
  1. 如何不冲突（多用户在同一目录下创建）
  2. 及时销毁
   
   - ```tmpnam```：返回一个临时文件名。（有一定危险性，进程调度） （除了单独一条机器指令不可以中断之外其他任何行为都可以中断的）
   - ```tmpfile```：产生一个匿名临时文件（ls找不到，没有名字那就不存在冲突），并且以读写方式打开。只要传给 ```fclose``` 就可以销毁了。


## 可控内存泄漏（不是守护进程）
- 一定程度的内存泄漏是可以接受的。