# 进程间通信

## 管道实例--池类算法（线程管道）
- 要求：永远都不要觉得自己在写main函数，永远要记得，自己在写一个模块，要以写库的标准来要求自己。（main函数永远都是测试用例）尽量少的在库里面报错，防止于用户之间的报错冲突。
要在手册上写好到底返回什么的时候是出错的，让用户自己来判断。

## 进程间通信
- 同一台主机的进程间通信，不同主机之间的进程通信。（QQ之类的）
  
### 管道
- 特点：内核创建和管理的进程管道，单工（一端读一端写），自适应的自同步机制->永远迁就慢的一方。
- 匿名管道：
- 命名管道：没有亲缘关系的进程用命名管道才可以通信。
- ```pipe()``` 创建匿名管道：具有亲缘关系的进程之间进行通信。通过fork就完事了。子写父读或者父写子读。
- 使用的时候最好把不用的端口关掉。
- man 一下mpg123
- ```mkfifo()```创建命名管道。 

### XSI-> SysV
- IPC-> Inter-Process comunication （进程间通信）(```ipcs```命令可查看)三种机制
- 主动端：先发包的一方。被动端：先收包的一方（先运行，等着收）
- Message Queues消息队列(双工，都能读都能写)：关键字msg。
  - 从严格的角度来讲，消息队列并不是以一个队列，因为它可以挑消息接受（接收函数里面有一个msgtype参数），不需要严格的遵循先进先出。
  - 对消息的结构体有规定，建议包含一定的信息（见man）。struct msgbuf:数组为1代表变长结构体。
  - mtype的作用：
  - 可以用ulimit来查看消息队列的资源上限。
  - 可以用man ipcs命令来看一下终止消息队列的命令


- semaphore array信号量数组：关键字sem
- share memory segmen共享内存：关键字shm
- key:一般用于无亲缘关系的进程通信。```ftok()```用于产生一个key值，用于通信，基于一个pathname和一个杂质串进行运算得到一个key_t类型的key。
- 函数： ```XXXget()``` ```XXXop()``` ```XXXctl()```上述三个类型的通信都是这样操作的。

### 网络套接字Socket（自己封装一些协议）


## 消息队列

## 共享项目内存
